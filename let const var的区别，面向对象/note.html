<!DOCTYPE html>
<html lang="en">

<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta http-equiv="X-UA-Compatible" content="ie=edge">
     <title>Document</title>
</head>

<body>


     <script>
          /*
     闭包的定义：
          1.函数就是闭包(局部变量不被外界所污染)
          2.函数可以使用函数之外定义的变量(ECMAscript定义)
          3.
          (function(i){
               btn[i].onclick = function(){
                    alert(i);
               }
               btn[i].onclick = null;
          })(i)   某个变量不被浏览器垃圾回收机制回收
          4.函数套函数，子函数引用父函数的参数或者变量并且子函数被外界所引用这个时候父级就形成闭包环境(父级的执行栈不被销毁),父级的参数或者变量不会被浏览器垃圾回收机制回收  此时打印父级的返回值查看scopes下有个closure，closure就是闭包

          闭包的应用就是存值

          原始值
               存储在栈(stack)中的简单数据段，他们的值直接存储在变量访问的位置
          引用值：
               存储在堆(heap)中的对象，也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存处

          var : 
               当通过var创建一个变量的时候，会进行预解析（变量提升）
               因为var会预解析，所以变量会当做属性存到全局的活动变量对象下(window下)
               不支持块级作用域

               不会主动存每次循环的值

          let 当通过var创建一个变量的时候，不会进行预解析(不会变量提升)不会在window下挂属性
               在定义变量之前访问这个变量，之前访问的空间叫暂存死区

          支持块级作用域

          会把每次循环的值存储起来
          不能声明同名的变量、函数、参数
          
          const 常量(不可变的量)
               当声明一个变量，不允许改变的时候就使用const定义
               不能声明一个变量、函数、参数

               注意：
                    const赋值的数据，他只会监控这个数据的地址

          块{}：
               在块套块中，子块有函数，如果在父块或者父块的上方访问这个函数那么都是undefined

               如果在子块的下方访问这个函数，就能找到这个函数

     */
          /* const obj = {
               name:'啧啧啧'
          }
          obj.name = '哈哈哈'
          console.log(obj); //obj{name:'哈哈哈'}  const赋值的数据，他只会监控这个数据的地址

          obj = {name:'xixixi'}//报错 */

          // console.log(a); //报错  not defined

          /*     {
                   let a = 10
              }
              console.log(a);//报错  not defined */
          /*  {
                let a =10;
                {
                     function fn(){console.log(a);}
                }
                console.log(fn);//fn函数
                fn()//10
           }
           fn()//10 */

          /*
          单例模式：
               单例：单独的实例
               实例：描述具体的是一个事务
               构造函数：抽象一个类的封装过程

               高级单例模式：
                    让当前这个实例功能更加强大，还可以隐藏或者暴露细节信息
                    (function(){
                         functions fn(){

                         }
                         return{

                         }
                    })()

          为什么要用高级单例模式：
                    让当前这个实例功能更加强大，还可以隐藏或者暴露内部细节信息
                    解决了命名冲突的问题
          高级单例模式如何写：
                    (function(){

                    return{

                    }
                    })()
                    最后一个让变量去收这个功能强大的对象
          解决命名冲突的问题:
                    1.封闭空间(把变量或者函数放到函数中)
                    let a = 10;
                    (function(){
                         let a =20
                    })()

               2.命名空间


          */

          /* let obj = (function(){
               let name ='狗';
               let age = 3 ;
               let foot = 4

               return{
                    name:name,
                    age:age,
                    foot:foot
               }
          })()
          console.log(obj); */

          /* let obj = (function(){
               let name = '冉';
               function Fn(name2,name3){
                    return name+name2+name3
               }
               return {
                    name:Fn('德','鹏')
               }
          })()
          console.log(obj); */
          /*
          工厂模式为了批量生产实例
          函数  目的就是为了复用 
          */
          /*  function fn(name,age,foot){
                let obj = {}
                obj.name = name;
                obj.age = age;
                obj.foot = foot ;
                return obj;
           }
           let obj1 = fn('哈士奇',5,4)
           let obj2 = fn('柯基',3,4)
          console.log(obj1,obj2);
           console.log(obj1.name == obj2.name);//false
           console.log(obj1.push == obj2.push);//true
            */
          /*
          面向对象是一种的现实世界理解和抽象的方法，是计算机发展到一定阶段后的产物

          JS是一个基于面向对象思想(基于对象的)构建出来的编程语言
          抽象：
               抽出像的部分(把相同的代码抽离出来)
          类 class

          为什么要用面向对象来编程?
               通过对象来编程，扩展性更强，能狗左到高内聚，低耦合
          面向对象:
               将具有相同特征特性的代码，抽离出来归为一类，然后把描述这个类的细节特性(属性、方法)挂在这个类的原型下的一种编程方式

          构造函数(类)
          
          */

          /*     function Person(name, age, sex) {
                   this.name = name;
                   this.age = age;
                   this.sex = sex;
              }
              let aa = new Person('张三', 12, '男')
              let bb = new Person('李四', 13, '女')
              console.log(aa, bb); */

          /*
          new 是函数一元运算符，专门运算函数的
          使用new之后会调用函数，就算不加()也会调用执行
          */
          /*    function fn(a){
                  console.log(123);
             }
             new fn; 
             */
          /*
          使用new之后，this变成了实例，实例就是一个对象(空对象)
          */

          /*  function fn(){
                console.log(this);//fn{}
                
           } */
          // new fn
          // fn()//window
          /*
          使用new之后，函数默认返回值为实例化对象，就不是undefined
          */
          // function fn(){

          // }
          // console.log(new fn)//fn{}
          /*
               如果return后面的有值，为原始类型，返回结果还是实例，如果return后面的值为引用类型，返回的结果就是return后面的引用类型
          */
          /* function fn(){
               // return  Symbol// Symbol() { [native code] }
               return '';
          }
          console.log(new fn); */

          /*
          在js中，所有的class(类)都是函数模拟出来的

          当声明一个函数的时候，这个函数自身有一些属性或者方法(天生自带)
          其中有一个属性叫做prototype，他的值为对象

          这个prototype就叫原型，也就是说函数身上才有原型
          函数原型下的属性或者方法只给构造函数的实例化对象使用
          Object.prototype.__proto__为null找到Object的原型下如果没有某个属性或者方法就真的没有了

          原型链：
               __proto__ 实例化对象下都有__proto__
               这个属性全等于 实例的构造函数的原型


          实例有原型链，函数有原形，原型又是一个对象，对象他就是实例，实例又有原型链，找到构造函数的原型
          */
          function Fn() {
               this.a = 10;
          }
          Fn.prototype.a = 20;
          Fn.a = 30;
          Fn.prototype.a = 40;
          Object.prototype.a = 60;
          Function.prototype.a = 50;
          Function.a = 70;
          let f = new Fn();
          f.a = 40;
          // console.log(f.__proto__.__proto__.a);
          // console.log(Fn.__proto__.a);
          console.log(Function.prototype.__proto__.a);
          
          
          // console.dir(f)
          console.dir(Fn)
          
     </script>
</body>

</html>+